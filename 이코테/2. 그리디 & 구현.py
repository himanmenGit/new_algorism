# 그리디 알고리즘 (탐욕법)
"""
현재 상황에서 지금 당장 좋은 것만 고르는 방법
문제를 풀기위한 최소한의 아이디어를 떠올릴 수 있는 능력 요구
정당성 분석이 중요
    단순히 가장 좋아 보이는것을 반복해서 선택해도 최적의 해를 구할 수 있는지 검토하는 과정이 필요
일반적인 상황에서 최적의 해를 보장할 수 없는 경우가 많다
코테에서는 대부분의 그리디 문제는 그리디로 얻은 해가 최적의 해가 되는 상황에서 이를 추론할 수 있어야 풀리도록 출제
"""

# 거스름돈: 문제 설명
"""
거스름돈 500, 100, 50, 10원
거슬러 줘야 할 돈이 N원 일 때
거슬러 주어야 할 최소 동전의 수
"""

# 거스름 돈: 문제 해결 아이디어
"""
최적의 해를 빠르게 구하기 위해 가장 큰 단위의 화폐부터 돈을 거슬러 줌
가장먼저 500원 거슬러 줄수 있을 만큼 거슬러 주고 이후에 차례대로 100, 50, 10 동전을 거슬러 주면된다.
N=1_260
500=2, 100=2, 50=1, 10=1
"""

# 거스름 돈: 정당성 분석
"""
가장 큰 단위 돈부터 거슬러 주는것이 최적의 해를 보장하는 이유는?
    가지고 있는 동전중 큰 단위가 항상 작은 단위의 배수 이므로 작은 단위의 동전들을 종합해 다른 해가 나올수 없기 떄문
만약 800원을 거슬러 주어야 하는데 500, 400, 100 이면 어떻게 될까?
"""

n = 1260
count = 0

array = [500, 100, 50, 10]
for coin in array:
    count += n // coin
    n %= coin
print(count)

# 거스름 돈: 시간 복잡도
"""
화폐의 종류가 K라고 할 때 소스코드의 시간 복잡도는 O(K)
동전의 총 종륲에만 영향을 받는다.
"""

# 1일 될 떄까지: 문제 설명
"""
어떠한 수 N이 1이 될 떄까지 두 과정 중 하나를 반복해서 수행
두 번째 연산은 N이 K로 나누어 떨어질 때만 선택 가능
1. N에서 1을 뺍니다
2. N을 K로 나눕니다
N=17, K=4
1(1)-> N=16 , 2(2)-> N=1
전체 과정은 3회
N,K가 주어 질떄 N이 1이 될 떄까지 1,2번 과정을 수행하는 최소 횟수를 구하라
"""

# 1이 될 떄까지: 문제 조건
"""
난이도 하, 풀이시간 15분, 시간제한 2초, 메모리 제한 128MB
입력 조건: 첫째 줄에는 N(1<=N<=100,000) 과 K(2<=K<=100,000) 공백 기준 자연수
출력 조건: 첫재 줄에 N이 1이 될때까지 수행되는 최소 횟수
"""

# 1이 될 떄까지: 문제 해결 아이디어
"""
주어진 N에 대하여 최대한 많이 나누기를 수행
N값을 줄일 때 2이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 많이 줄일 수 있다
"""

# 1이 될 때까지: 정당성 분석
"""
가능하면 최대한 많이 나누는 작업이 최적의 해를 보장하나
N이 아무리 큰 수여도 K로 계속 나누면 빠르게 줄일 수 있다
K가 2 이상이기만 하면 K로 나누는 것이 1을 빼는것보다 빠르다
N은 항상 1에 도달하게 된다
"""

N, K = map(int, input().split())
count = 0

while N != 1:
    print(N)
    if N % K == 0:
        N = N // K
        count += 1
    else:
        N -= 1
        count += 1
print(count)

N, K = map(int, input().split())
result = 0

while True:
    # N이 K로 나누어 떨어지는 수가 될 떄까지 빼기
    # N이 K로 나누어 질수 있는 가장 가까운 수 찾기
    target = (N // K) * K
    # 원래값에서 K로 나누어 떨어 지는 수를 빼서 -1이 몇번 되었는지 result에 더함
    result += (N - target)
    N = target

    if N < K:
        break
    # 다시 한번더 K로 나누어서 result를 증가
    result += 1
    N //= K

# 마지막 N 1이 아닐 수 있으므로 N에서 1을 뺴주어 result에 더함
result += (N - 1)
print(result)

# 곱하기 혹은 더하기: 무넺 설명
"""
각자리가 0~9까지 이루어진 문자열S
왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하여 'x', '+'연산자를 넣어 결과 적으로
가장큰 수를 만들 수 있는 프로그램
모든 연산은 왼쪽에서 부터 순서대로
02984 ->((((0+2)x9)x8)x4) = 576
만들어 질수 있는 가장 큰수는 20억 이하의 정수가 되도록 한다.
"""

# 곱하기 혹은 더하기: 문제 조건
"""
난이도 하, 풀이시간 30분, 시간제한 1초 , 메모리 제한 128MB
1 <= S <= 20
가장 큰 수 출력
"""

S = list(map(int, '02984'))
result = 0
for s in S:
    if s <= 1:
        result += s
    else:
        if result == 0:
            result = 1
        result *= s

print(result)

S = list(map(int, '02984'))
result = S[0]

for i in range(1, len(S)):
    num = S[i]
    if num <= 1 or result <= 1:
        result += num
    else:
        result *= num
print(result)
